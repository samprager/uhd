<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>USRP Hardware Driver and USRP Manual: USRP N3xx Series</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="Ettus_Logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">USRP Hardware Driver and USRP Manual
   &#160;<span id="projectnumber">Version: 3.14.0.rfnoc-devel-783-g9e1383d8</span>
   </div>
   <div id="projectbrief">UHD and USRP Manual</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('page_usrp_n3xx.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">USRP N3xx Series </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#n3xx_feature_list">Comparative features list</a><ul><li class="level2"><a href="#n3xx_feature_list_mg">N310/N300 4-channel/2-channel (&quot;Magnesium&quot;)</a></li>
</ul>
</li>
<li class="level1"><a href="#n3xx_overview">Overview</a><ul><li class="level2"><a href="#n3xx_zynq">The Zynq CPU/FPGA and host operating system</a></li>
<li class="level2"><a href="#n3xx_micro">The STM32 microcontroller</a></li>
<li class="level2"><a href="#n3xx_sdcard">The SD card</a></li>
</ul>
</li>
<li class="level1"><a href="#n3xx_getting_started">Getting started</a><ul><li class="level2"><a href="#n3xx_getting_started_assembling">Assembling the N3XX</a></li>
<li class="level2"><a href="#n3xx_getting_started_fs_update">Updating the file system</a></li>
<li class="level2"><a href="#n3xx_getting_started_serial">Serial connection</a><ul><li class="level3"><a href="#n3xx_getting_started_serial_micro">Connecting to the microcontroller</a></li>
</ul>
</li>
<li class="level2"><a href="#n3xx_getting_started_ssh">SSH connection</a></li>
<li class="level2"><a href="#n3xx_getting_started_connectivity">Network Connectivity</a></li>
<li class="level2"><a href="#n3xx_getting_started_security">Security-related settings</a></li>
<li class="level2"><a href="#n3xx_getting_started_fpga_update">Updating the FPGA</a></li>
</ul>
</li>
<li class="level1"><a href="#n3xx_usage">Using an N3XX USRP from UHD</a><ul><li class="level2"><a href="#n3xx_usage_device_args">Device arguments</a></li>
<li class="level2"><a href="#n3xx_usage_init">Device Initialization</a></li>
<li class="level2"><a href="#n3xx_usage_subdevspec">Subdev Specifications</a></li>
<li class="level2"><a href="#n3xx_usage_sensors">The sensor API</a></li>
</ul>
</li>
<li class="level1"><a href="#n3xx_rasm">Remote Management</a><ul><li class="level2"><a href="#n3xx_rasm_mender">Mender: Remote update capability</a></li>
<li class="level2"><a href="#n3xx_rasm_salt">Salt: Remote configuration management and execution</a></li>
</ul>
</li>
<li class="level1"><a href="#n3xx_synchronization">Clock/Time Synchronization</a><ul><li class="level2"><a href="#n3xx_synchronization_internal">Internal references</a></li>
<li class="level2"><a href="#n3xx_synchronization_external">External references</a></li>
<li class="level2"><a href="#n3xx_synchronization_whiterabbit">White Rabbit</a></li>
</ul>
</li>
<li class="level1"><a href="#n3xx_troubleshooting">Troubleshooting</a><ul><li class="level2"><a href="#n3xx_troubleshooting_seqerrs">Errors while streaming</a></li>
</ul>
</li>
<li class="level1"><a href="#n3xx_theory_of_ops">Theory of Operation</a></li>
<li class="level1"><a href="#n3xx_fsbuild">Building custom filesystems and SD card images</a><ul><li class="level2"><a href="#n3xx_fsbuild_docker">Using Docker to build filesystems</a></li>
</ul>
</li>
<li class="level1"><a href="#n3xx_software_dev">Modifying and compiling UHD and MPM for the N3XX</a><ul><li class="level2"><a href="#n3xx_software_dev_mpm_native">Compiling MPM natively</a></li>
<li class="level2"><a href="#n3xx_software_dev_sdk">Obtaining an SDK</a></li>
<li class="level2"><a href="#n3xx_software_dev_sdkusage">SDK Usage</a><ul><li class="level3"><a href="#n3xx_software_dev_uhd">Building UHD</a></li>
<li class="level3"><a href="#n3xx_software_dev_gr">Building GNU Radio</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#n3xx_mg">N310-specific Features</a><ul><li class="level2"><a href="#n3xx_mg_panels">Front and Rear Panel</a></li>
<li class="level2"><a href="#n3xx_mg_initialization">Device Initialization (Fast and Slow)</a></li>
<li class="level2"><a href="#n3xx_mg_calibrations">RF Calibrations</a></li>
<li class="level2"><a href="#n3xx_mg_external_lo">External LOs</a></li>
<li class="level2"><a href="#n3xx_mg_eeprom">Storing user data in the EEPROM</a></li>
<li class="level2"><a href="#n3xx_mg_regmap">FPGA Register Map</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="n3xx_feature_list"></a>
Comparative features list</h1>
<ul>
<li>Hardware Capabilities:<ul>
<li>Dual SFP+ Transceivers (can be used with 1 GigE, 10 GigE, and Aurora)</li>
<li>External PPS input &amp; output</li>
<li>External 10 MHz input &amp; output (20 MHz and 25 MHz inputs also supported)</li>
<li>External White Rabbit time/frequency reference input support</li>
<li>Internal 25 MHz reference clock</li>
<li>Internal GPSDO for timing, location, and 20 MHz reference clock + PPS</li>
<li>External GPIO Connector with UHD API control</li>
<li>External USB Connection for built-in JTAG debugger and serial console</li>
<li>Xilinx Zynq SoC with dual-core ARM Cortex A9 (Speedgrade 2) and Kintex-7 FPGA (XC7Z100 or XC7Z035 depending on variant)</li>
</ul>
</li>
<li>Software Capabilities:<ul>
<li>Full Linux system running on the ARM core</li>
<li>Runs MPM (see also <a class="el" href="page_mpm.html">The Module Peripheral Manager (MPM) Architecture</a>)</li>
</ul>
</li>
<li>FPGA Capabilities:<ul>
<li>Timed commands in FPGA</li>
<li>Timed sampling in FPGA</li>
<li>RFNoC capability</li>
</ul>
</li>
</ul>
<p>The N3XX series of USRPs is designed as a platform. The following USRPs are variants of the N3XX series:</p>
<h2><a class="anchor" id="n3xx_feature_list_mg"></a>
N310/N300 4-channel/2-channel ("Magnesium")</h2>
<div class="image">
<img src="N310isoExplode.png" alt="N310isoExplode.png"/>
<div class="caption">
N310 Exploded View</div></div>
<p>The N310 is a 4-channel transmitter/receiver based on the AD9371 transceiver IC. It has two daughterboards with one AD9371 each; every daughterboard provides two RF channels. Note that the product code "N310" refers to the module consisting of mother- and daughterboard, the daughterboard itself is referred to by its codename, "Magnesium".</p>
<ul>
<li>Supported master clock rates: 122.88 MHz, 125 MHz, 153.6 MHz</li>
<li>Tuning range: 10 MHz to 6 GHz (below 300 MHz, additional LOs and mixer stages are used to shift the signal into the frequency range of the AD9371)</li>
<li>Support for external LOs</li>
<li>4 RX DDC chains in FPGA (2 for N300)</li>
<li>4 TX DUC chain in FPGA (2 for N300)</li>
</ul>
<p>The N300 is a subset of the N310. It has 2 TX/RX channels (on a single daughterboard; the daughterboard itself is the same as the N310) and a smaller FPGA (XCZ035). Also, it does not have connectors for external LOs.</p>
<h1><a class="anchor" id="n3xx_overview"></a>
Overview</h1>
<h2><a class="anchor" id="n3xx_zynq"></a>
The Zynq CPU/FPGA and host operating system</h2>
<p>The main CPU of the N310 is a Xilinx Zynq SoC XC7Z100 (exception: The N300). It is both a dual-core ARM Cortex A9 CPU and Kintex-7 FPGA on a single die. The CPU is clocked at 800 MHz (speedgrade 2).</p>
<p>The programmable logic (PL, or FPGA) section of the SoC is responsible for handling all sampling data, the 10 GigE network connections, and any other high-speed utility such as custom RFNoC logic. The processing system (PS, or CPU) is running a custom-build OpenEmbedded-based Linux operating system. The OS is responsible for all the device and peripheral management, such as running MPM, configuring the network interfaces, running local UHD sessions, etc.</p>
<p>It is possible to connect to the host OS either via SSH or serial console (see sections <a class="el" href="page_usrp_n3xx.html#n3xx_getting_started_ssh">SSH connection</a> and <a class="el" href="page_usrp_n3xx.html#n3xx_getting_started_serial">Serial connection</a>, respectively).</p>
<h2><a class="anchor" id="n3xx_micro"></a>
The STM32 microcontroller</h2>
<p>The STM32 microcontroller controls various low-level features of the N3xx series motherboard: It controls the power sequencing, reads out fan speeds and some of the temperature sensors. It is connected to the Zynq via an I2C bus.</p>
<p>It is possible to log into the STM32 using the serial interface (see <a class="el" href="page_usrp_n3xx.html#n3xx_getting_started_serial_micro">Connecting to the microcontroller</a>). This will allow certain low-level controls, such as remote power cycling should the CPU have become unresponsive for whatever reason.</p>
<h2><a class="anchor" id="n3xx_sdcard"></a>
The SD card</h2>
<p>The N3XX series uses a micro SD card as its main storage. The entire root file system (Linux kernel, libraries) and any user data are stored on this SD card.</p>
<p>The SD card is partitioned into four partitions:</p>
<ol type="1">
<li>Boot partition (contains the bootloader). This partition usually does not require touching.</li>
<li>A data partition, mounted in /data. This is the only partition that is not erased during file system updates.</li>
</ol>
<ol type="1">
<li>Two identical system partitions (root file systems). These contain the operating system and the home directory (anything mounted under / that is not the data or boot partition). The reason there are two of these is to enable remote updates: An update running on one partition can update the other one without any effect to the currently running system. Note that the system partitions are erased during updates and are thus unsuitable for permanently storing information.</li>
</ol>
<p>Note: It is possible to access the currently inactive root file system by mounting it. After logging into the device using serial console or SSH (see the following two sections), run the following commands: </p><pre class="fragment">$ mkdir temp
$ mount /dev/mmcblk0p3 temp
$ ls temp # You are now accessing the idle partition:
bin   data  etc   lib         media  proc  sbin  tmp    usr
boot  dev   home  lost+found  mnt    run   sys   uboot  var
</pre><p>The device node in the mount command will likely differ, depending on which partition is currently already mounted.</p>
<h1><a class="anchor" id="n3xx_getting_started"></a>
Getting started</h1>
<p>This will run you through the first steps relevant to getting your USRP N3XX series up and running.</p>
<h2><a class="anchor" id="n3xx_getting_started_assembling"></a>
Assembling the N3XX</h2>
<p>Unlike the X300 or N200 series, there is no assembly of daughterboards required. Members of the N3XX product family, such as the N310, ship with daughterboards pre-installed.</p>
<p>Checklist:</p><ul>
<li>Connect power and network</li>
<li>Read security settings</li>
<li>Connect clocking (if required)</li>
<li>Connect external LOs (if required)</li>
</ul>
<h2><a class="anchor" id="n3xx_getting_started_fs_update"></a>
Updating the file system</h2>
<p>Before doing any major work with a newly acquired USRP N300/N310, it is recommended to update the file system. Updating the filesystem can be accomplished directly on the N300/N310 by using Mender or externally by manually writing an image onto a micro SD card and inserting it. While manual updating is faster, Mender requires no direct physical access to the device. For details on using Mender, see Section <a class="el" href="page_usrp_n3xx.html#n3xx_rasm_mender">Mender: Remote update capability</a> .</p>
<p>Manual updating is simply loading an image on the micro SD card. The first step in that process is to obtain an image.</p>
<p>To obtain the default micro SD card image for a specific version of UHD, install that version of UHD (3.11.0.1 or later) on a host system with Internet access and run: </p><pre class="fragment">$ uhd_images_downloader -t n3xx_common_sdimg_default
</pre><p>The image will be downloaded to <code>&lt;UHD_INSTALL_DIR&gt;/share/uhd/images/usrp_n3xx_fs.sdimg</code>, where <code>&lt;UHD_INSTALL_DIR&gt;</code> is the UHD installation directory.</p>
<p>To load an image onto the micro SD card, connect the card to the host and run: </p><pre class="fragment">$ sudo dd if=&lt;YOUR_IMAGE&gt; of=/dev/&lt;YOUR_SD_CARD&gt; bs=1M
</pre><p>The <code>&lt;YOUR_IMAGE&gt;</code> is the path to the micro SD card image (i.e.<code>&lt;UHD_INSTALL_DIR&gt;/share/uhd/images/usrp_n3xx_fs.sdimg</code>).</p>
<p>The <code>&lt;YOUR_SD_CARD&gt;</code> device node depends on your operating system and which other devices are plugged in. Typical values are <code>sdb</code> or <code>mmcblk0</code>.<br />
 CAUTION: Operating on the wrong device can cause damage to that device.</p>
<p>The micro SD card used can be the original SD card shipped with the device or another one that is at least 16 GB in size.</p>
<p>Insert the updated micro SD card and power on the device.</p>
<h2><a class="anchor" id="n3xx_getting_started_serial"></a>
Serial connection</h2>
<p>It is possible to gain root access to the device using a serial terminal emulator. Most Linux, OSX, or other Unix flavours have a tool called 'screen' which can be used for this purpose, by running the following command: </p><pre class="fragment">$ sudo screen /dev/ttyUSB2 115200
</pre><p>In this command, we prepend 'sudo' to elevate user privileges (by default, accessing serial ports is not available to regular users), we specify the device node (in this case, <code>/dev/ttyUSB2</code>), and the baud rate (115200).</p>
<p>The exact device node depends on your operating system's driver and other USB devices that might be already connected. Modern Linux systems offer alternatives to simply trying device nodes; instead, the OS might have a directory of symlinks under <code>/dev/serial/by-id</code>: </p><pre class="fragment">$ ls /dev/serial/by-id
usb-Digilent_Digilent_USB_Device_25163511FE00-if00-port0
usb-Digilent_Digilent_USB_Device_25163511FE00-if01-port0
usb-Silicon_Labs_CP2105_Dual_USB_to_UART_Bridge_Controller_007F6CB5-if00-port0
usb-Silicon_Labs_CP2105_Dual_USB_to_UART_Bridge_Controller_007F6CB5-if01-port0
</pre><p>Note: Exact names depend on the host operating system version and may differ.</p>
<p>Every N3XX series device connected to USB will by default show up as four different devices. The devices labeled "USB_to_UART_Bridge_Controller" are the devices that offer a serial prompt. The first (with the <code>if00</code> suffix) connects to Linux, whereas the second connects to the STM32 microcontroller. If you have multiple N3XX devices connect, you may have to try out multiple devices. In this case, to use this symlink instead of the raw device node address, modify the command above to: </p><pre class="fragment">$ sudo screen /dev/serial/by-id/usb-Silicon_Labs_CP2105_Dual_USB_to_UART_Bridge_Controller_007F6CB5-if00-port0 115200
</pre><p>You should be presented with a shell prompt similar to the following: </p><pre class="fragment">root@ni-n3xx-311FE00:~#
</pre><p>On this prompt, you can enter any Linux command available. Using the default configuration, the serial console will also show all kernel log messages (unlike when using SSH, for example), and give access to the boot loader (U-boot prompt). This can be used to debug kernel or bootloader issues more efficiently than when logged in via SSH.</p>
<h3><a class="anchor" id="n3xx_getting_started_serial_micro"></a>
Connecting to the microcontroller</h3>
<p>The STM32 microcontroller (which controls the power sequencing, among other things) also has a serial console available. To connect to the microcontroller, use the other UART device. In the example above: </p><pre class="fragment">$ sudo screen /dev/serial/by-id/usb-Silicon_Labs_CP2105_Dual_USB_to_UART_Bridge_Controller_007F6CB5-if01-port0 115200
</pre><p>It provides a very simple prompt. The command 'help' will list all available commands. A direct connection to the microcontroller can be used to hard-reset the device without physically accessing it (i.e., emulating a power button press) and other low-level diagnostics.</p>
<h2><a class="anchor" id="n3xx_getting_started_ssh"></a>
SSH connection</h2>
<p>The USRP N-Series devices have two network connections: The dual SFP ports, and an RJ-45 connector. The latter is by default configured by DHCP; by plugging it into into 1 Gigabit switch on a DHCP-capable network, it will get assigned an IP address and thus be accessible via ssh.</p>
<p>In case your network setup does not include a DHCP server, refer to the section <a class="el" href="page_usrp_n3xx.html#n3xx_getting_started_serial">Serial connection</a>. A serial login can be used to assign an IP address manually.</p>
<p>After the device obtained an IP address you can log in from a Linux or OSX machine by typing: </p><pre class="fragment">$ ssh root@ni-n3xx-311FE00 # Replace with your actual device name!
</pre><p>Depending on your network setup, using a <code>.local</code> domain may work: </p><pre class="fragment">$ ssh root@ni-n3xx-311FE00.local
</pre><p>Of course, you can also connect to the IP address directly if you know it (or set it manually using the serial console).</p>
<p>Note: The device's hostname is derived from its serial number by default (<code>ni-n3xx-$SERIAL</code>). You can change the hostname by modifying the <code>/etc/hostname</code> file and rebooting.</p>
<p>On Microsoft Windows, the connection can be established using a tool such as Putty, by selecting a username of root without password.</p>
<p>Like with the serial console, you should be presented with a prompt like the following: </p><pre class="fragment">root@ni-n3xx-311FE00:~#
</pre><h2><a class="anchor" id="n3xx_getting_started_connectivity"></a>
Network Connectivity</h2>
<p>The RJ45 port (eth0) comes up with a default configuration of DHCP, that will request a network address from your DHCP server (if available on your network).</p>
<p>The SFP+ (sfp0, sfp1) ports are configured with static addresses 192.168.10.2/24 and 192.168.20.2/24, respectively. Their default MTU value is 8000. These settings are independent of the image type (HG vs. XG), i.e., the defaults are the same for 1 GigE and 10 GigE (unlike the X310!).</p>
<p>The configuration for the sfpX port is stored in /etc/systemd/network/sfpX.network.</p>
<p>For configuration please refer to the <a href="https://www.freedesktop.org/software/systemd/man/systemd.network.html">systemd-networkd manual pages</a></p>
<p>The factory settings are as follows: </p><pre class="fragment">eth0 (DHCP):

    [Match]
    Name=eth0

    [Network]
    DHCP=v4

    [DHCPv4]
    UseHostname=false

sfp0 (static):

    [Match]
    Name=sfp0

    [Network]
    Address=192.168.10.2/24

    [Link]
    MTUBytes=8000

sfp1 (static):

    [Match]
    Name=sfp1

    [Network]
    Address=192.168.20.2/24

    [Link]
    MTUBytes=8000
</pre><p>Additional notes on networking:</p>
<ul>
<li>Care needs to be taken when editing these files on the device, since vi / vim sometimes generates undo files (e.g. <code>/etc/systemd/network/sfp0.network~</code>), that systemd-networkd might accidentally pick up.</li>
<li>Temporarily setting the IP addresses or MTU sizes via <code>ifconfig</code> or other command line tools will only change the value until the next reboot or reload of the FPGA image.</li>
<li>If the MTU of the device and host computers differ, streaming issues can occur.</li>
</ul>
<h2><a class="anchor" id="n3xx_getting_started_security"></a>
Security-related settings</h2>
<p>The N3XX ships without a root password set. It is possible to ssh into the device by simply connecting as root, and thus gaining access to all subsystems. To set a password, run the command </p><pre class="fragment">$ passwd
</pre><p>on the device.</p>
<h2><a class="anchor" id="n3xx_getting_started_fpga_update"></a>
Updating the FPGA</h2>
<p>Updating the FPGA follows the same procedure as other USRPs. Use the <code>uhd_image_loader</code> command line utility to upload a new FPGA image onto the device.</p>
<p>A common reason to update the FPGA image is in the case of a UHD/FPGA compat number mismatch (for example, if UHD has been updated, and now expects a newer version of the FPGA than is on the device). In this case, simply run </p><pre class="fragment">$ uhd_images_downloader
</pre><p>to update the local cache of FPGA images. Then, run </p><pre class="fragment">$ uhd_image_loader --args type=n3xx,addr=ni-n3xx-311fe00
</pre><p>to update the FPGA using the default settings. If a custom FPGA image is targeted for uploading, use the <code>--fpga-path</code> command line argument. Run </p><pre class="fragment">$ uhd_image_loader --help
</pre><p>to see a full list of command line options. Note that updating the FPGA image will force a reload of the FPGA, which will temporarily take down the SFP network interfaces (and temporary settings, such as applied via <code>ifconfig</code> on the command line, will be lost).</p>
<h1><a class="anchor" id="n3xx_usage"></a>
Using an N3XX USRP from UHD</h1>
<p>Like any other USRP, all N3XX USRPs are controlled by the UHD software. To integrate a USRP N3XX into your C++ application, you would generate a UHD device in the same way you would for any other USRP:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> usrp = <a class="code" href="classuhd_1_1usrp_1_1multi__usrp.html#af0d3809a8f8dcd3c962ad5b9a0a6456c">uhd::usrp::multi_usrp::make</a>(<span class="stringliteral">&quot;type=n3xx&quot;</span>);</div></div><!-- fragment --><p>For a list of which arguments can be passed into make(), see Section <a class="el" href="page_usrp_n3xx.html#n3xx_usage_device_args">Device arguments</a>.</p>
<h2><a class="anchor" id="n3xx_usage_device_args"></a>
Device arguments</h2>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Key  </th><th class="markdownTableHeadNone">Description  </th><th class="markdownTableHeadNone">Supported Devices  </th><th class="markdownTableHeadNone">Example Value ---&mdash;   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">addr  </td><td class="markdownTableBodyNone">IPv4 address of primary SFP+ port to connect to.  </td><td class="markdownTableBodyNone">All N3xx  </td><td class="markdownTableBodyNone">addr=192.168.30.2   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">second_addr  </td><td class="markdownTableBodyNone">IPv4 address of secondary SFP+ port to connect to.  </td><td class="markdownTableBodyNone">All N3xx  </td><td class="markdownTableBodyNone">second_addr=192.168.40.2   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">mgmt_addr  </td><td class="markdownTableBodyNone">IPv4 address or hostname which to connect the RPC client. Defaults to &lsquo;addr&rsquo;.  </td><td class="markdownTableBodyNone">All N3xx  </td><td class="markdownTableBodyNone">mgmt_addr=ni-sulfur-311FE00 (can also go to RJ45)   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">find_all  </td><td class="markdownTableBodyNone">When using broadcast, find all devices, even if unreachable via CHDR.  </td><td class="markdownTableBodyNone">All N3xx  </td><td class="markdownTableBodyNone">find_all=1   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">force_reinit  </td><td class="markdownTableBodyNone">Force full reinitialization of all subsystems. Will increase init time.  </td><td class="markdownTableBodyNone">N310  </td><td class="markdownTableBodyNone">force_reinit=1   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">master_clock_rate  </td><td class="markdownTableBodyNone">Master Clock Rate in Hz  </td><td class="markdownTableBodyNone">N310  </td><td class="markdownTableBodyNone">master_clock_rate=125e6   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">identify  </td><td class="markdownTableBodyNone">Causes front-panel LEDs to blink. The duration is variable.  </td><td class="markdownTableBodyNone">N310  </td><td class="markdownTableBodyNone">identify=5 (will blink for about 5 seconds)   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">serialize_init  </td><td class="markdownTableBodyNone">Force serial initialization of daughterboards.  </td><td class="markdownTableBodyNone">All N3xx  </td><td class="markdownTableBodyNone">serialize_init=1   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">skip_dram  </td><td class="markdownTableBodyNone">Ignore DRAM FIFO block. Connect TX streamers straight into DUC or radio.  </td><td class="markdownTableBodyNone">All N3xx  </td><td class="markdownTableBodyNone">skip_dram=1   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">skip_ddc  </td><td class="markdownTableBodyNone">Ignore DDC block. Connect Rx streamers straight into radio.  </td><td class="markdownTableBodyNone">All N3xx  </td><td class="markdownTableBodyNone">skip_ddc=1   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">skip_duc  </td><td class="markdownTableBodyNone">Ignore DUC block. Connect Rx streamers or DRAM straight into radio.  </td><td class="markdownTableBodyNone">All N3xx  </td><td class="markdownTableBodyNone">skip_duc=1   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">skip_init  </td><td class="markdownTableBodyNone">Skip the initialization process for the device.  </td><td class="markdownTableBodyNone">All N3xx  </td><td class="markdownTableBodyNone">skip_init=1   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">time_source  </td><td class="markdownTableBodyNone">Specify the time (PPS) source.  </td><td class="markdownTableBodyNone">All N3xx  </td><td class="markdownTableBodyNone">time_source=internal   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">clock_source  </td><td class="markdownTableBodyNone">Specify the reference clock source.  </td><td class="markdownTableBodyNone">All N3xx  </td><td class="markdownTableBodyNone">clock_source=internal   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">ref_clk_freq  </td><td class="markdownTableBodyNone">Specify the external reference clock frequency, default is 10 MHz.  </td><td class="markdownTableBodyNone">N310  </td><td class="markdownTableBodyNone">ref_clk_freq=20e6   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">init_cals  </td><td class="markdownTableBodyNone">Specify the bitmask for initial calibrations of the RFIC.  </td><td class="markdownTableBodyNone">N310  </td><td class="markdownTableBodyNone">init_cals=BASIC   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">init_cals_timeout  </td><td class="markdownTableBodyNone">Timeout for initial calibrations in milliseconds.  </td><td class="markdownTableBodyNone">N310  </td><td class="markdownTableBodyNone">init_cals_timeout=45000   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">discovery_port  </td><td class="markdownTableBodyNone">Override default value for MPM discovery port.  </td><td class="markdownTableBodyNone">All N3xx  </td><td class="markdownTableBodyNone">discovery_port=49700   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">rpc_port  </td><td class="markdownTableBodyNone">Override default value for MPM RPC port.  </td><td class="markdownTableBodyNone">All N3xx  </td><td class="markdownTableBodyNone">rpc_port=49701   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">tracking_cals  </td><td class="markdownTableBodyNone">Specify the bitmask for tracking calibrations of the RFIC.  </td><td class="markdownTableBodyNone">N310  </td><td class="markdownTableBodyNone">tracking_cals=ALL   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">rx_lo_source  </td><td class="markdownTableBodyNone">Initialize the source for the RX LO.  </td><td class="markdownTableBodyNone">N310  </td><td class="markdownTableBodyNone">rx_lo_source=external   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">tx_lo_source  </td><td class="markdownTableBodyNone">Initialize the source for the TX LO.  </td><td class="markdownTableBodyNone">N310  </td><td class="markdownTableBodyNone">tx_lo_source=external   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">rfic_digital_loopback  </td><td class="markdownTableBodyNone">Digital data loopback inside the RFIC.  </td><td class="markdownTableBodyNone">N310  </td><td class="markdownTableBodyNone">rfic_digital_loopback=1   </td></tr>
</table>
<h2><a class="anchor" id="n3xx_usage_init"></a>
Device Initialization</h2>
<p>To maximally speed up UHD, an initialization sequence is run when the device (or more accurately, the MPM service) starts. This means even on the first run of UHD, the device will already be initialized into a usable state. Note that it will always come up in a default state, which can be changed by modifying the configuration file in <code>/etc/uhd/mpm.conf</code> (see also <a class="el" href="page_configfiles.html">Configuration Files</a>), such as this:</p>
<div class="fragment"><div class="line">; Note: To boot into a fully initialized state, a clock reference must be</div><div class="line">; connected before turning the device on if it set to external here:</div><div class="line">[n3xx]</div><div class="line">clock_source=external</div></div><!-- fragment --><p>If you prefer not to have the device initialize on boot, but rather have a fast boot time, add the line <code>skip_boot_init=1</code> to your <code>/etc/uhd/mpm.conf</code> file.</p>
<p>For more details on the initialization sequence, see the corresponding section for the specific N3XX device:</p><ul>
<li><a class="el" href="page_usrp_n3xx.html#n3xx_mg_initialization">Device Initialization (Fast and Slow)</a></li>
</ul>
<h2><a class="anchor" id="n3xx_usage_subdevspec"></a>
Subdev Specifications</h2>
<p>The four RF ports on the front panel correspond to the following subdev specifications:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Label  </th><th class="markdownTableHeadNone">Subdev Spec   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">RF0  </td><td class="markdownTableBodyNone">A:0   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">RF1  </td><td class="markdownTableBodyNone">A:1   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">RF2  </td><td class="markdownTableBodyNone">B:0 (N310 only)   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">RF3  </td><td class="markdownTableBodyNone">B:1 (N310 only)   </td></tr>
</table>
<p>Note: Before UHD 3.12.0.0, the subdev spec options were different (A:0, B:0, etc.). Make sure to update your application if you migrated from an earlier UHD version.</p>
<p>The following example will map RF0 onto channel 0 of a <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html">uhd::usrp::multi_usrp</a> object, and RF3 onto channel 1:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> usrp = <a class="code" href="classuhd_1_1usrp_1_1multi__usrp.html">uhd::usrp::multi_usrp</a>(<span class="stringliteral">&quot;type=n3xx&quot;</span>);</div><div class="line">usrp-&gt;set_rx_subdev_spec(<span class="stringliteral">&quot;A:0 B:1&quot;</span>);</div><div class="line"><span class="comment">// This line will now set the gain for RF3 to 20.0:</span></div><div class="line">usrp-&gt;set_rx_gain(20.0, 1);</div><div class="line"><span class="comment">// And this will affect RF0:</span></div><div class="line">usrp-&gt;set_rx_gain(20.0, 0);</div></div><!-- fragment --><p>See also <a class="el" href="classuhd_1_1usrp_1_1subdev__spec__t.html">uhd::usrp::subdev_spec_t</a>.</p>
<h2><a class="anchor" id="n3xx_usage_sensors"></a>
The sensor API</h2>
<p>Like other USRPs, the N3x0 series have daughterboard and motherboard sensors. When using <a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html">uhd::usrp::multi_usrp</a>, the following API calls are relevant to interact with the sensor API:</p>
<ul>
<li><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a3a72259c19b80512dba02e40ed5cf028">uhd::usrp::multi_usrp::get_mboard_sensor_names()</a></li>
<li><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a2d3c327bcb83fd274e05e3ca95d1ac95">uhd::usrp::multi_usrp::get_mboard_sensor()</a></li>
<li><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a33a556057ceabc00ab2af61525f206fd">uhd::usrp::multi_usrp::get_tx_sensor_names()</a></li>
<li><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a87d3d097b6cb1cfa940896e71e5f44ad">uhd::usrp::multi_usrp::get_rx_sensor_names()</a></li>
<li><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#a482d52c0983c6db913209e57f9b79c3a">uhd::usrp::multi_usrp::get_tx_sensor()</a></li>
<li><a class="el" href="classuhd_1_1usrp_1_1multi__usrp.html#acd37d327931cec64e3701eb2a5aa7bfb">uhd::usrp::multi_usrp::get_rx_sensor()</a></li>
</ul>
<p>The following motherboard sensors are always available:</p>
<ul>
<li><code>ref_locked</code>: This will check that all the daughterboards have locked to the external reference.</li>
<li><code>temperature</code>: The temperature of the die itself</li>
<li><code>gps_lock</code>: GPS lock</li>
<li><code>gps_time</code>: GPS time in seconds sin ce the epch</li>
<li><code>gps_tpv</code>: A TPV report from GPSd serialized as JSON</li>
<li><code>gps_sky</code>: A SKY report from GPSd serialized as JSON</li>
</ul>
<h1><a class="anchor" id="n3xx_rasm"></a>
Remote Management</h1>
<h2><a class="anchor" id="n3xx_rasm_mender"></a>
Mender: Remote update capability</h2>
<p>Mender is a third-party software that enables remote updating of the root file system without physically accessing the device (see also the <a href="https://mender.io">Mender website</a>). Mender can be executed locally on the device, or a Mender server can be set up which can be used to remotely update an arbitrary number of USRP devices. Mender servers can be self-hosted, or hosted by Mender (see <a href="https://mender.io">mender.io</a> for pricing and availability).</p>
<p>When updating the file system using Mender, the tool will overwrite the root file system partition that is not currently mounted (note: every SD card comes with two separate root file system partitions, only one is ever used at a single time). Any data stored on that partition will be permanently lost. After updating that partition, it will reboot into the newly updated partition. Only if the update is confirmed by the user, the update will be made permanent. This means that if an update fails, the device will be always able to reboot into the partition from which the update was originally launched (which presumably is in a working state). Another update can be launched now to correct the previous, failed update, until it works. See also Section <a class="el" href="page_usrp_n3xx.html#n3xx_sdcard">The SD card</a>.</p>
<p>To initiate an update from the device itself, download a Mender artifact containing the update itself. These are files with a <code>.mender</code> suffix.</p>
<p>Then run mender on the command line: </p><pre class="fragment">$ mender -rootfs /path/to/latest.mender
</pre><p>The artifact can also be stored on a remote server: </p><pre class="fragment">$ mender -rootfs http://server.name/path/to/latest.mender
</pre><p>This procedure will take a while. After mender has logged a successful update, reboot the device: </p><pre class="fragment">$ reboot
</pre><p>If the reboot worked, and the device seems functional, commit the changes so the boot loader knows to permanently boot into this partition: </p><pre class="fragment">$ mender -commit
</pre><p>To identify the currently installed Mender artifact from the command line, the following file can be queried: </p><pre class="fragment">$ cat /etc/mender/artifact_info
</pre><p>If you are running a hosted server, the updates can be initiated from a web dashboard. From there, you can start the updates without having to log into the device, and can update groups of USRPs with a few clicks in a web GUI. The dashboard can also be used to inspect the state of USRPs. This is simple way to update groups of rack-mounted USRPs with custom file systems.</p>
<h2><a class="anchor" id="n3xx_rasm_salt"></a>
Salt: Remote configuration management and execution</h2>
<p>Salt (also known as SaltStack, see <a href="https://saltstack.com">Salt Website</a>) is a Python-based tool for maintaining fleets of remote devices. It can be used to manage USRP N3XX series remotely for all types of settings that are not controlled by UHD. For example, if an operator would like to reset the root password on multiple devices, or install custom software, this tool might be a suitable choice.</p>
<p>Salt is a third-party project with its <a href="https://docs.saltstack.com/en/latest/">own documentation</a>, which should be consulted for configuring it. However, the Salt minion is installed by default on every N3XX device. To start it, simply log on to the device and run: </p><pre class="fragment">$ systemctl start salt-minion
</pre><p>To permanently enable it at every boot, run (this won't by itself launch the salt-minion): </p><pre class="fragment">$ systemctl enable salt-minion
</pre><h1><a class="anchor" id="n3xx_synchronization"></a>
Clock/Time Synchronization</h1>
<h2><a class="anchor" id="n3xx_synchronization_internal"></a>
Internal references</h2>
<p>The N3xx series has an onboard GPSDO as well as a 25 MHz reference oscillator, which can both be used as time- and clock references. The GPSDO will function as a reference even when there is no GPS reception.</p>
<p>Note that this does not enable the synchronization of multiple devices. Using an internal reference is the default.</p>
<h2><a class="anchor" id="n3xx_synchronization_external"></a>
External references</h2>
<p>In order to synchronize multiple USRPs, an external reference, such as the CDA-2990, is required. If only a clock reference is available, it is possible to derive an internal PPS signal from the reference (which will allow devices to share a frequency, but not a time reference). If both an external clock and time source are provided, devices will be synchronized in frequency and time.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> usrp = <a class="code" href="classuhd_1_1usrp_1_1multi__usrp.html#af0d3809a8f8dcd3c962ad5b9a0a6456c">uhd::usrp::multi_usrp::make</a>(<span class="stringliteral">&quot;type=n3xx,clock_source=external,time_source=external&quot;</span>);</div></div><!-- fragment --><h2><a class="anchor" id="n3xx_synchronization_whiterabbit"></a>
White Rabbit</h2>
<p>White Rabbit is an Ethernet-based synchronization procedure; it is an extension of the IEEE 1588 Precision Time Protocol (PTP). The N3xx device can be configured as a White Rabbit slave.</p>
<p>To use White Rabbit, it is necessary to provide an appropriate reference via Ethernet. This reference must be connected to SFP0. Finally, a White Rabbit-compatible FPGA must be loaded. SFP0 will not be available for data transport in this mode.</p>
<p>The White Rabbit image is provided as a default image. To obtain the default images, simply run: </p><pre class="fragment">$ uhd_images_downloader -t n3xx -t fpga
</pre><p>Then, you can install the WX (or WA) image using <code>uhd_image_loader</code>: </p><pre class="fragment">$ uhd_image_loader --args type=n3xx,addr=ni-n3xx-&lt;DEVICE_SERIAL&gt; --fpga-path=‚Äù&lt;UHD_INSTALL_DIRECTORY&gt;/share/uhd/images/usrp_n310_fpga_WX.bit
</pre><p>Once the image is loaded, select <code>internal</code> as the clock source and <code>sfp0</code> as the time source:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> usrp = <a class="code" href="classuhd_1_1usrp_1_1multi__usrp.html#af0d3809a8f8dcd3c962ad5b9a0a6456c">uhd::usrp::multi_usrp::make</a>(<span class="stringliteral">&quot;type=n3xx,clock_source=internal,time_source=sfp0&quot;</span>);</div></div><!-- fragment --><p>For more information, refer to the <a href="https://www.ohwr.org/projects/white-rabbit">White Rabbit Homepage</a>, or the <a href="https://kb.ettus.com/Using_Ethernet-Based_Synchronization_on_the_USRP%E2%84%A2_N3xx_Devices">Ettus Research Knowledge Base</a>.</p>
<h1><a class="anchor" id="n3xx_troubleshooting"></a>
Troubleshooting</h1>
<h2><a class="anchor" id="n3xx_troubleshooting_seqerrs"></a>
Errors while streaming</h2>
<p>If you are getting sequence or other errors while streaming, make sure the MTU settings of the network devices match up. UHD will try and do an automatic MTU discovery, but there are cases when the automatic MTU discovery will yield incorrect values. Often, the host computer MTU is set smaller than the device MTU, but the MTU discovery will detect a larger MTU than the host computer MTU in this error case.</p>
<p>The default MTU for the N3x0 series is 8000. The simplest solution is often to set the host computer MTU to 8000 as well: </p><pre class="fragment">$ [sudo] ifconfig eth0 mtu 8000 # Replace eth0 with the device you're using
</pre><p>Of course, you can also reduce the MTU on the device to match your host computer, see Section <a class="el" href="page_usrp_n3xx.html#n3xx_getting_started_connectivity">Network Connectivity</a>.</p>
<h1><a class="anchor" id="n3xx_theory_of_ops"></a>
Theory of Operation</h1>
<p>The N3xx-series are devices based on the MPM architecture (see also: <a class="el" href="page_mpm.html">The Module Peripheral Manager (MPM) Architecture</a>). Inside the Linux operating system running on the ARM cores, there is hardware daemon which needs to be active in order for the device to function as a USRP (it is enabled to run by default).</p>
<p>A large portion of hardware-specific setup is handled by the daemon.</p>
<h1><a class="anchor" id="n3xx_fsbuild"></a>
Building custom filesystems and SD card images</h1>
<p>Ettus Research provides SD card images at regular intervals, but there can be good reasons to build custom SD cards, e.g., to test the very latest UHD or MPM for which there has not been an SD card release, to add own applications to the SD card, or to run a modified version of UHD.</p>
<p>Note that building SD cards is very disk space and RAM intensive.</p>
<h2><a class="anchor" id="n3xx_fsbuild_docker"></a>
Using Docker to build filesystems</h2>
<p>Ettus Research provides a Docker containers to facilitate building filesystems. Using Docker hub, the container can be downloaded by running </p><pre class="fragment">$ docker pull ettusresearch/oe-build
</pre><p>Then, navigate to a location with enough disk space: </p><pre class="fragment">$ cd $BUILDDIR
</pre><p>Create a world-writable directory called 'build':</p>
<p>$ mkdir build &amp;&amp; chmod 777 build</p>
<p>Then run the Docker container: </p><pre class="fragment">$ docker run -i -t -v $(pwd)/build:/home/oe-builder/build:rw,z ettusresearch/oe-build /bin/bash
</pre><p>Note the order of the naming above might vary by docker version, sometimes it might need to be: </p><pre class="fragment">$ docker run -i -t ettusresearch/oe-build -v $(pwd)/build:/home/oe-builder/build:rw,z /bin/bash
</pre><p>After running the previous command, you will be inside the container. First, configure your build environment:</p>
<p>$ TEMPLATECONF=<code>pwd</code>/meta-ettus/conf/sulfur source ./oe-core/oe-init-build-env ./build ./bitbake</p>
<p>Then, you can invoke bitbake to build the image: </p><pre class="fragment">$ bitbake $image_name
</pre><p>If you keep the build directory, bitbake will reuse it on consecutive runs, which will speed up builds significantly between runs.</p>
<p>This step will build the SDK, the SD card image, and the Mender artefact.</p>
<h1><a class="anchor" id="n3xx_software_dev"></a>
Modifying and compiling UHD and MPM for the N3XX</h1>
<p>N3xx devices ship with all relevant software installed on the SD card. Updating UHD and/or MPM on the SD card is typically easiest done by updating the filesystem image (see Section <a class="el" href="page_usrp_n3xx.html#n3xx_rasm_mender">Mender: Remote update capability</a>). However, it is certainly possible to compile UHD and MPM by hand, e.g., in order to modify and try out changes without having to build entire filesystems in between. At Ettus R&amp;D, this mode of operation is often used for rapid iteration cycles.</p>
<h2><a class="anchor" id="n3xx_software_dev_mpm_native"></a>
Compiling MPM natively</h2>
<p>In general, compiling natively is not a recommended way of compiling code for the ARM processors. However, in the case of MPM, the amount of C++ code that needs to be compiled is very little, and a full compile of MPM will take a few minutes even on the N3xx. First, you need to get a copy of the MPM source code onto your device. If you have an internet connection, you can use git to pull it directly from the Ettus repository (all commands are run on the device itself, inside the home directory): </p><pre class="fragment">$ git clone https://github.com/EttusResearch/uhd.git
</pre><p>You can also SSHFS it from another computer: </p><pre class="fragment">$ mkdir uhd # Create a new, empty directory called uhd
$ sshfs user@yourcomputer:src/uhd uhd # This will mount ~/src/uhd from the remote machine to ~/uhd on the N3xx
</pre><p>Now, create a build directory and use the regular cmake/make procedure to kick off a build. It can be advantageous (especially for slow network connections) to create the build directory outside of the repository directory: </p><pre class="fragment">$ mkdir build_mpm
$ cd build_mpm # You are now in /home/root/build_mpm
$ cmake ../uhd/mpm
$ make -j2 install # This will take several minutes
</pre><p>Note that this overwrites your system MPM. You can install MPM to another location by specifying <code>-DCMAKE_INSTALL_PREFIX</code>, but make sure to update all of your paths appropriately.</p>
<p>If you prefer cross-compiling MPM the same way as UHD, refer to the following sections and adapt the instructions for UHD appropriately.</p>
<h2><a class="anchor" id="n3xx_software_dev_sdk"></a>
Obtaining an SDK</h2>
<p>The recommended way to develop software for the N3xx is to cross-compile. By running the compiles on a desktop or laptop computer, you will be able to speed up compile times considerably (compiling UHD natively for the N3xx would take many hours).</p>
<p>SDKs are distributed along with other binaries. They contain a cross-compiler, a cross-linker, a cross-debugger, and all the libraries available on the device to mirror its environment.</p>
<p>The SDK is shipped in the same way as the other binaries, and you can download the correct version using <code>uhd_images_downloader</code> </p><pre class="fragment">$ uhd_images_downloader -t sdk -t n3xx
</pre><p>To unpack and install the SDK, simply execute it after downloading it: </p><pre class="fragment">$ cd /usr/local/share/uhd/images # Change this to where your images are stored
$ ./oecore-x86_64-cortexa9hf-neon-toolchain-nodistro.0.sh
</pre><p>This will prompt you for an installation path. Please ensure you have sufficient disk space, as each of the SDKs may require several gigabytes of disk space (depending on the image flavor selected).</p>
<p>This will allow you to compile UHD as well as (depending on the image flavor) other software, such as GNU Radio.</p>
<p>Please note, that while several toolchains can be installed in parallel, they have to be installed to different directories.</p>
<h2><a class="anchor" id="n3xx_software_dev_sdkusage"></a>
SDK Usage</h2>
<p>Having installed the toolchain in the last step, in order to build software for your device open a new shell and type: </p><pre class="fragment">$ . $SDKPATH/environment-setup-armv7ahf-vfp-neon-oe-linux-gnueabi
</pre><p>This will modify the PATH, CC, CXX etc, environment variables and allow you to compile software for your USRP N3xx device. To verify all went well you can try: </p><pre class="fragment">$ $CC -dumpmachine
</pre><p>which should return 'arm-oe-linux-gnueabi'.</p>
<h3><a class="anchor" id="n3xx_software_dev_uhd"></a>
Building UHD</h3>
<ol type="1">
<li>Obtain the UHD source code via git or tarball</li>
<li>Set up your environment as described in <a class="el" href="page_usrp_n3xx.html#n3xx_software_dev_sdkusage">SDK Usage</a></li>
<li>Type the following in the build directory (assuming a build in host/build): <pre class="fragment"> $ cmake -DCMAKE_TOOLCHAIN_FILE=../host/cmake/Toolchains/oe-sdk_cross.cmake -DCMAKE_INSTALL_PREFIX=/usr .. # Add any CMake options you desire
 $ make # You can run make -j12 to compile on 12 processes at once
</pre></li>
</ol>
<p>Note: The UHD you are cross-compiling will not run on your host computer (the one where you're doing the development). Compiling UHD regularly on your host computer (with MPMD enabled) will allow you to talk to your N3xx.</p>
<h3><a class="anchor" id="n3xx_software_dev_gr"></a>
Building GNU Radio</h3>
<ol type="1">
<li>Obtain the GNU Radio source code via git or tarball</li>
<li>Set up your environment as described in <a class="el" href="page_usrp_n3xx.html#n3xx_software_dev_sdkusage">SDK Usage</a></li>
<li>Use the following commands to create a build directory, configure and compile gnuradio. You only need create the build directory once.</li>
</ol>
<div class="fragment"><div class="line">$ mkdir build-arm</div><div class="line">$ cd build-arm</div><div class="line">$ cmake -Wno-dev -DCMAKE_TOOLCHAIN_FILE=../cmake/Toolchains/oe-sdk_cross.cmake \-DCMAKE_INSTALL_PREFIX=/usr -DENABLE_GR_VOCODER=OFF -DENABLE_GR_ATSC=OFF \</div><div class="line">-DENABLE_GR_DTV=OFF -DENABLE_DOXYGEN=OFF ../ # Append any CMake options you desire</div></div><!-- fragment --><p>Several GNU Radio components depend on running binaries built for the build machine during compile. These binaries can be built and used for cross compiling, but this is an advanced topic.</p>
<h1><a class="anchor" id="n3xx_mg"></a>
N310-specific Features</h1>
<h2><a class="anchor" id="n3xx_mg_panels"></a>
Front and Rear Panel</h2>
<p>Like the USRP X300 series, the N310 has connectors on both the front and back panel. The back panel holds the power connector, all network connections, USB connections for serial console (see <a class="el" href="page_usrp_n3xx.html#n3xx_getting_started_serial">Serial connection</a>), JTAG, peripherals, SMA connectors for GPS antenna input, 10 MHz clock reference, PPS time reference input and output (TRIG in/out), the slot for the SD card (see also <a class="el" href="page_usrp_n3xx.html#n3xx_sdcard">The SD card</a>), and indicator LEDs.</p>
<p>The following indicator LEDs are used:</p>
<ul>
<li>LINK: This LED will be lit when this USRP has been claimed by a UHD session.</li>
<li>REF: Indicates a lock to the reference clock. In particular, when using an external reference clock, this LED is useful to see if the LMK04828 PLLs are locking to this reference clock. Note that some software interaction is necessary to enable the LMK04828, and thus this LED may be off even if a valid reference clock signal is connected.</li>
<li>GPS: Indicates a GPS lock (i.e., GPS satellites are in view of the GPS antenna and signal levels are sufficient)</li>
<li>PPS: This LED will blink once every second to indicate a valid PPS signal.</li>
</ul>
<div class="image">
<img src="N310rp.png" alt="N310rp.png"/>
<div class="caption">
N310 Rear Panel</div></div>
<p>The front panel is used for all RF connections (including the external LO inputs, see <a class="el" href="page_usrp_n3xx.html#n3xx_mg_external_lo">External LOs</a>) and all TX/RX connections, as well as the front-panel GPIO.</p>
<p>The connectors labeled RF0 and RF1 are also referred to as slot A, and the connectors labeled RF2 and RF3 are also referred as slot B (matching the internal connections to the daughterboard. Every slot is powered by a single AD9371 RFIC).</p>
<div class="image">
<img src="N310fp.png" alt="N310fp.png"/>
<div class="caption">
N310 Front Panel</div></div>
<h2><a class="anchor" id="n3xx_mg_initialization"></a>
Device Initialization (Fast and Slow)</h2>
<p>When a UHD session is created, an initialization sequence is started. As part of the initialization sequence, the following steps are performed:</p>
<ul>
<li>All clocking is initialized</li>
<li>The JESD links are trained and brought up (between the FPGA and the AD9371)</li>
<li>The AD9371 is reset, its firmware is uploaded, and calibrations are initialized (See also <a class="el" href="page_usrp_n3xx.html#n3xx_mg_calibrations">RF Calibrations</a>)</li>
<li>N310 only: The multi-chip synchronization is performed to align all the RFICs to the common time and clock reference</li>
</ul>
<p>This sequence can take a while, depending on the master clock rate and the calibration sequence. To speed things up, the device will retain a state between sessions, but only if no relevant settings were touched. In particular, changing the master clock rate, the clock source, or the calibration masks will force a full re-initialization which is very slow compared to the fast re-initialization. By setting the log level to DEBUG you will be able to observe the exact settings that cause fast vs. slow re-initialization. If you require a full re-initialization every time a UHD session is spawned, specify the <code>force_reinit</code> flag as a device arg. Specifying it will always do the full, slow initialization, but will guarantee a full reset of the RFIC.</p>
<p>To maximally speed up UHD, an initialization sequence is run when the device (or more accurately, the MPM service) starts. This means even on the first run of UHD, the device will already be initialized into a usable state. Note that it will always come up in a default state, which can be changed by modifying the configuration file in <code>/etc/uhd/mpm.conf</code> (see also <a class="el" href="page_configfiles.html">Configuration Files</a>), such as this:</p>
<div class="fragment"><div class="line">; Note: To boot into a fully initialized state, a clock reference must be</div><div class="line">; connected before turning the device on if it set to external here:</div><div class="line">[n3xx]</div><div class="line">master_clock_rate=122.88e6</div><div class="line">clock_source=external</div></div><!-- fragment --><p>If you prefer not to have the device initialize on boot, but rather have a fast boot time, add the line <code>skip_boot_init=1</code> to your <code>/etc/uhd/mpm.conf</code> file.</p>
<h2><a class="anchor" id="n3xx_mg_calibrations"></a>
RF Calibrations</h2>
<p>The onboard RFIC (AD9371) has built-in calibrations which can be enabled from UHD. A more detailed description of the calibrations can be found in the AD9371 user guide, see chapter "Quadrature Error Correction, Calibration, and ARM
configuration".</p>
<p>Not all calibrations available on the AD9371 are applicable to the USRP N310. However, those calibrations that are applicable can be enabled/disabled at initialization time using the <code>tracking_cals</code> and <code>init_cals</code> device args (see also <a class="el" href="page_usrp_n3xx.html#n3xx_usage_device_args">Device arguments</a>). These device can be set to the precise bit mask the chip uses to set those calibrations (e.g., <code>init_cals=0x4DFF,tracking_cals=0xC3</code>) or they can use the following descriptive keys provided by UHD (e.g.<code>init_cals=DEFAULT,tracking_cals=TX_QEC|RX_QEC</code>). The <code>|</code> symbol can be used to combine keys (equivalent to a bitwise OR).</p>
<p>Calibrations can significantly delay the initialization of a session. By only picking relevant calibrations, sessions can be initialized faster.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Key (<code>init_cal</code>)  </th><th class="markdownTableHeadNone">Function ---------------------&mdash;   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">TX_BB_FILTER  </td><td class="markdownTableBodyNone">Tx baseband filter calibration   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">ADC_TUNER  </td><td class="markdownTableBodyNone">ADC tuner calibration   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">TIA_3DB_CORNER  </td><td class="markdownTableBodyNone">Rx TIA filter calibration   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">DC_OFFSET  </td><td class="markdownTableBodyNone">Rx DC offset calibration   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">TX_ATTENUATION_DELAY  </td><td class="markdownTableBodyNone">Tx attenuation delay   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">RX_GAIN_DELAY  </td><td class="markdownTableBodyNone">Rx gain delay calibration   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">FLASH_CAL  </td><td class="markdownTableBodyNone">ADC flash calibration   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">PATH_DELAY  </td><td class="markdownTableBodyNone">Path delay calibration   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">TX_LO_LEAKAGE_INTERNAL  </td><td class="markdownTableBodyNone">Tx LO leakage internal initial calibration   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">TX_LO_LEAKAGE_EXTERNAL  </td><td class="markdownTableBodyNone">Tx LO leakage external initial calibration (requires external LO)   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">TX_QEC_INIT  </td><td class="markdownTableBodyNone">Tx QEC initial   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">LOOPBACK_RX_LO_DELAY  </td><td class="markdownTableBodyNone">Loopback ORx LO delay (ORx not connected by default!)   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">LOOPBACK_RX_RX_QEC_INIT  </td><td class="markdownTableBodyNone">Loopback Rx QEC initial calibration   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">RX_LO_DELAY  </td><td class="markdownTableBodyNone">Rx LO delay   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">RX_QEC_INIT  </td><td class="markdownTableBodyNone">Rx QEC initial calibration   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">BASIC  </td><td class="markdownTableBodyNone">Preset for minimal calibrations (TX_BB_FILTER, ADC_TUNER, TIA_3DB_CORNER, DC_OFFSET and FLASH_CAL)   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">OFF  </td><td class="markdownTableBodyNone">Preset for disabling all initial calibrations   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">DEFAULT  </td><td class="markdownTableBodyNone">Preset for enabling most calibrations (BASIC plus TX_ATTENUATION_DELAY, RX_GAIN_DELAY, PATH_DELAY, RX_QEC_INIT, TX_LO_LEAKAGE_INTERNAL, TX_QEC_INIT, LOOPBACK_RX_LO_DELAY)   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">ALL  </td><td class="markdownTableBodyNone">Enable all applicable calibrations   </td></tr>
</table>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Key (<code>tracking_cal</code>)  </th><th class="markdownTableHeadNone">Function ---------------------&mdash;   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">TRACK_RX1_QEC  </td><td class="markdownTableBodyNone">Rx1 QEC tracking   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">TRACK_RX2_QEC  </td><td class="markdownTableBodyNone">Rx2 QEC tracking   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">TRACK_ORX1_QEC  </td><td class="markdownTableBodyNone">ORx1 QEC tracking   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">TRACK_ORX2_QEC  </td><td class="markdownTableBodyNone">ORx1 QEC tracking   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">TRACK_TX1_LOL  </td><td class="markdownTableBodyNone">Tx1 LO leakage tracking   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">TRACK_TX2_LOL  </td><td class="markdownTableBodyNone">Tx2 LO leakage tracking   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">TRACK_TX1_QEC  </td><td class="markdownTableBodyNone">Tx1 QEC tracking   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">TRACK_TX2_QEC  </td><td class="markdownTableBodyNone">Tx2 QEC tracking   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">OFF  </td><td class="markdownTableBodyNone">Disable all tracking   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">RX_QEC  </td><td class="markdownTableBodyNone">Enable all RX QEC tracking   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">TX_QEC  </td><td class="markdownTableBodyNone">Enable all TX QEC tracking   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">TX_LOL  </td><td class="markdownTableBodyNone">Enable all TX LO leakage tracking   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">DEFAULT  </td><td class="markdownTableBodyNone">Enable all QEC tracking   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">ALL  </td><td class="markdownTableBodyNone">Enable all tracking (except ORx)   </td></tr>
</table>
<h2><a class="anchor" id="n3xx_mg_external_lo"></a>
External LOs</h2>
<p>The N310 has inputs for external local oscillators. For every daughterboard, there is one input for TX and RX, respectively, resulting in 4 LO inputs total per N310.</p>
<p>Reasons to use an external LO include:</p>
<ul>
<li>Improving phase alignment: The N310 itself has no way of aligning phase between channels, and phase will be random between runs. By applying an external LO, the phase ambiguity is reduced to 180 degrees, produced by a by-2 divider in the AD9371 transceiver IC.</li>
<li>Improving phase noise: The quality of the onboard LO depends on the external reference clock, among other things. By providing a custom LO signal, it is possible to more accurately tune, assuming the externally generated LO signal is coming from a high-quality oscillator.</li>
</ul>
<h2><a class="anchor" id="n3xx_mg_eeprom"></a>
Storing user data in the EEPROM</h2>
<p>The N310 daughterboard has an EEPROM which is primarily used for storing the serial number, product ID, and other product-specific information. However, it can also be used to store user data, such as calibration information.</p>
<p>Note that EEPROMs have a limited number of write cycles, and storing user data should happen only when necessary. Writes should be kept at a minimum.</p>
<p>Storing data on the EEPROM is done by loading a <a class="el" href="namespaceuhd.html#a3dfa664f90d28b4e602a6d780ce0edd0">uhd::eeprom_map_t</a> object into the property tree. On writing this property, the driver code will serialize the map into a binary representation that can be stored on the EEPROM.</p>
<h2><a class="anchor" id="n3xx_mg_regmap"></a>
FPGA Register Map</h2>
<p>The following tables describe how FPGA registers are mapped into the PS. This is for reference only, most users will not even have to know about this table.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">AXI Slave  </th><th class="markdownTableHeadNone">Address Range  </th><th class="markdownTableHeadNone">UIO Label  </th><th class="markdownTableHeadNone">Description -------&mdash;   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Slave 0  </td><td class="markdownTableBodyNone">4000_0000 - 4000_3fff  </td><td class="markdownTableBodyNone">-  </td><td class="markdownTableBodyNone">Ethernet DMA SFP0   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">Slave 1  </td><td class="markdownTableBodyNone">4000_4000 - 4000_4fff  </td><td class="markdownTableBodyNone">misc-enet-regs0  </td><td class="markdownTableBodyNone">Ethernet registers SFP0   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Slave 2  </td><td class="markdownTableBodyNone">4000_8000 - 4000_bfff  </td><td class="markdownTableBodyNone">-  </td><td class="markdownTableBodyNone">Ethernet DMA SFP1   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">Slave 3  </td><td class="markdownTableBodyNone">4000_c000 - 4000_cfff  </td><td class="markdownTableBodyNone">misc-enet-regs1  </td><td class="markdownTableBodyNone">Ethernet registers SFP1   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Slave 4  </td><td class="markdownTableBodyNone">4001_0000 - 4001_3fff  </td><td class="markdownTableBodyNone">mboard-regs  </td><td class="markdownTableBodyNone">Motherboard control   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">Slave 5  </td><td class="markdownTableBodyNone">4001_4000 - 4001_41ff  </td><td class="markdownTableBodyNone">dboard-regs0  </td><td class="markdownTableBodyNone">Daughterboard control, slot A   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Slave 6  </td><td class="markdownTableBodyNone">4001_8000 - 4001_bfff  </td><td class="markdownTableBodyNone">dboard-regs1  </td><td class="markdownTableBodyNone">Daughterboard control, slot B   </td></tr>
</table>
<a class="anchor" id="multi_row"></a>
<table class="doxtable">
<caption>N310 Register Map</caption>
<tr>
<th>AXI Slave </th><th>Module </th><th>Address </th><th>Name </th><th>Read/Write </th><th>Description </th></tr>
<tr>
<td rowspan="1">Slave 0 </td><td rowspan="1">axi_eth_dma0 </td><td>4000_0000 - 4000_4fff </td><td>Ethernet DMA </td><td>RW </td><td>See Linux Driver </td></tr>
<tr>
<td rowspan="44">Slave 1 </td><td rowspan="7">n3xx_mgt_io_core </td><td>4000_4000 </td><td>PORT_INFO </td><td>RO </td><td>SFP port information </td></tr>
<tr>
<td>[31:24] </td><td>COMPAT_NUM </td><td>RO </td><td>- </td></tr>
<tr>
<td>[23:18] </td><td>6'h0 </td><td>RO </td><td>- </td></tr>
<tr>
<td>[17] </td><td>activity </td><td>RO </td><td>- </td></tr>
<tr>
<td>[16] </td><td>link_up </td><td>RO </td><td>- </td></tr>
<tr>
<td>[15:8] </td><td>mgt_protocol </td><td>RO </td><td>0 - None, 1 - 1G, 2 - XG, 3 - Aurora </td></tr>
<tr>
<td>[7:0] </td><td>PORTNUM </td><td>RO </td><td>- </td></tr>
<tr>
<td rowspan="8">n3xx_mgt_io_core </td><td>4000_4004 </td><td>MAC_CTRL_STATUS </td><td>RW </td><td>Control 10gE and Aurora mac </td></tr>
<tr>
<td>[0] </td><td>ctrl_tx_enable (PROTOCOL = "10GbE")</td><td>RW</td><td>- </td></tr>
<tr>
<td>[0] </td><td>bist_checker_en (PROTOCOL = "Aurora")</td><td>RW</td><td>- </td></tr>
<tr>
<td>[1] </td><td>bist_gen_en </td><td>RW </td><td>- </td></tr>
<tr>
<td>[2] </td><td>bist_loopback_en</td><td>RW </td><td>- </td></tr>
<tr>
<td>[8:3] </td><td>bist_gen_rate </td><td>RW </td><td>- </td></tr>
<tr>
<td>[9] </td><td>phy_areset </td><td>RW </td><td>- </td></tr>
<tr>
<td>[10] </td><td>mac_clear </td><td>RW </td><td>- </td></tr>
<tr>
<td>n3xx_mgt_io_core </td><td>4000_4008 </td><td>PHY_CTRL_STATUS </td><td>RW </td><td>Phy reset control </td></tr>
<tr>
<td rowspan="3">n3xx_mgt_io_core </td><td>4000_400C </td><td>MAC_LED_CTL </td><td>RW </td><td>Used by ethtool to indicate port </td></tr>
<tr>
<td>[1] </td><td>identify_enable </td><td>RW </td><td>- </td></tr>
<tr>
<td>[0] </td><td>identify_value </td><td>RW </td><td>- </td></tr>
<tr>
<td rowspan="4">mdio_master </td><td>4000_4010 </td><td>MDIO_DATA </td><td>RW </td><td>- </td></tr>
<tr>
<td>4000_4014 </td><td>MDIO_ADDR </td><td>RW </td><td>- </td></tr>
<tr>
<td>4000_4018 </td><td>MDIO_OP </td><td>RW </td><td>- </td></tr>
<tr>
<td>4000_401C </td><td>MDIO_CTRL_STATUS</td><td>RW </td><td>- </td></tr>
<tr>
<td rowspan="4">n3xx_mgt_io_core </td><td>4000_4020 </td><td>AURORA_OVERUNS </td><td>RO </td><td>- </td></tr>
<tr>
<td>4000_4024 </td><td>AURORA_CHECKSUM_ERRORS</td><td>RO </td><td>- </td></tr>
<tr>
<td>4000_4028 </td><td>AURORA_BIST_CHECKER_SAMPS</td><td>RO </td><td>- </td></tr>
<tr>
<td>4000_402C </td><td>AURORA_BIST_CHECKER_ERRORS</td><td>RO</td><td>- </td></tr>
<tr>
<td rowspan="4">eth_switch </td><td>4000_5000 </td><td>MAC_LSB </td><td>RW </td><td>Device MAC LSB </td></tr>
<tr>
<td>4000_5004 </td><td>MAC_MSB </td><td>RW </td><td>Device MAC MSB </td></tr>
<tr>
<td>4000_6000 </td><td>IP </td><td>RW </td><td>Device IP </td></tr>
<tr>
<td>4000_6004 </td><td>PORT1, PORT0 </td><td>RW </td><td>Device UDP port </td></tr>
<tr>
<td rowspan="2">eth_dispatch </td><td>4000_6008 </td><td>[1] ndest, [0] bcast</td><td>RW </td><td>Enable Crossover </td></tr>
<tr>
<td>4000_600c </td><td>[1] my_icmp_type, [0] my_icmp_code</td><td></td></tr>
<tr>
<td rowspan="5">eth_switch </td><td>4000_6010 </td><td>BRIDGE_MAC_LSB </td><td></td><td>Bridge SFP ports in ARM </td></tr>
<tr>
<td>4000_6014 </td><td>BRIDGE_MAC_MSB </td><td></td><td>- </td></tr>
<tr>
<td>4000_6018 </td><td>BRIDGE_IP </td><td></td><td>- </td></tr>
<tr>
<td>4000_601c </td><td>BRIDGE_PORT1, BRIDGE_PORT0</td><td></td><td>- </td></tr>
<tr>
<td>4000_6020 </td><td>BRIDGE_EN </td><td></td><td>- </td></tr>
<tr>
<td rowspan="6">chdr_eth_framer </td><td>4000_6108 onwards </td><td>LOCAL_DST_IP </td><td>W </td><td>Destination IP, MAC, UDP for Outgoing Packet for 256 SIDs </td></tr>
<tr>
<td>4000_6208 onwards </td><td>LOCAL_DST_UDP_MAC_MSB</td><td>W </td><td>Destination MAC for outgoing packets (MSB) </td></tr>
<tr>
<td>4000_6308 onwards </td><td>LOCAL_DST_MAC_LSB</td><td>W </td><td>Destination MAC for outgoing packets (LSB) </td></tr>
<tr>
<td>4000_7000 onwards </td><td>REMOTE_DST_IP </td><td>W </td><td>Destination IP, MAC, UDP for Outgoing Packet for 16 local addrs </td></tr>
<tr>
<td>4000_7400 onwards </td><td>REMOTE_DST_UDP_MAC_HI</td><td>W </td><td>Destination MAC (MSB) </td></tr>
<tr>
<td>4000_7800 onwards </td><td>REMOTE_DST_MAC_LO</td><td>W </td><td><p class="starttd">Destination MAC (LSB)</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td rowspan="1">Slave 2 </td><td>axi_eth_dma1 </td><td>4000_8000 </td><td>- </td><td></td><td><p class="starttd">Same as Slave 0, different base address</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td rowspan="3">Slave 3 </td><td>n3xx_mgt_io_core </td><td>4000_c001 - 4000_cfff </td><td>- </td><td>- </td><td>Same as Slave 1, different base address </td></tr>
<tr>
<td>eth_dispatch </td><td>4000_d000 - 4000_dfff </td><td>- </td><td>- </td><td>Same as Slave 1, different base address </td></tr>
<tr>
<td>eth_switch </td><td>4000_e000 - 4000_efff </td><td>- </td><td>- </td><td><p class="starttd">Same as Slave 1, different base address</p>
<p class="endtd"></p>
</td></tr>
<tr>
<td rowspan="69">Slave 4 </td><td rowspan="22">n310_core </td><td>4001_0000 </td><td>COMPAT_NUM </td><td>R </td><td>FPGA Compat Number </td></tr>
<tr>
<td>[31:16] </td><td>Major </td><td>RO </td><td>- </td></tr>
<tr>
<td>[15:0] </td><td>Minor </td><td>RO </td><td>- </td></tr>
<tr>
<td>4001_0004 </td><td>DATESTAMP </td><td>RO </td><td>- </td></tr>
<tr>
<td>4001_0008 </td><td>GIT_HASH </td><td>RO </td><td>- </td></tr>
<tr>
<td>4001_000C </td><td>SCRATCH </td><td>RO </td><td>- </td></tr>
<tr>
<td>4001_0010 </td><td>NUM_CE </td><td>RO </td><td>Number of Computation Engines (RFNoC Blocks) </td></tr>
<tr>
<td>4001_0014 </td><td>NUM_IO_CE </td><td>RO </td><td>Number of fixed IO CEs - Radios + DMA Fifo </td></tr>
<tr>
<td>4001_0018 </td><td>CLOCK_CTRL </td><td></td><td></td></tr>
<tr>
<td>[0] </td><td>pps select (internal 10 MHz)</td><td>RW</td><td>One-hot encoded pps_select to use the external PPS input. </td></tr>
<tr>
<td>[1] </td><td>pps select (internal 25 MHz)</td><td>RW</td><td>One-hot encoded pps_select to use the internally generated PPS with a 10 MHz ref_clk. </td></tr>
<tr>
<td>[2] </td><td>pps select (external)</td><td>RW </td><td>One-hot encoded pps_select to use the internally generated PPS with a 25 MHz ref_clk. </td></tr>
<tr>
<td>[3] </td><td>pps select (GPSDO)</td><td>RW </td><td>One-hot encoded pps_select to use the PPS from the GPSDO input to the FPGA. </td></tr>
<tr>
<td>[4] </td><td>pps output enable</td><td>RW </td><td></td></tr>
<tr>
<td>[8] </td><td>ref clk mmcm reset</td><td>WO </td><td>- </td></tr>
<tr>
<td>[9] </td><td>ref clk mmcm locked</td><td>RO </td><td>- </td></tr>
<tr>
<td>[12] </td><td>meas clk mmcm reset</td><td>WO </td><td>- </td></tr>
<tr>
<td>[13] </td><td>meas clk mmcm locked</td><td>RO </td><td>- </td></tr>
<tr>
<td>4001_001C </td><td>XADC_READBACK </td><td>RO </td><td>- </td></tr>
<tr>
<td>[11:0] </td><td>FPGA temperature</td><td>RO </td></tr>
<tr>
<td>4001_0020 </td><td>BUS_CLK_RATE </td><td>RO </td><td>- </td></tr>
<tr>
<td>4001_0024 </td><td>BUS_CLK_COUNT </td><td>RO </td><td>- </td></tr>
<tr>
<td rowspan="5">axi_crossbar </td><td>4001_1010 </td><td>XBAR_VERSION </td><td>RO </td><td>See crossbar kernel driver </td></tr>
<tr>
<td>4001_1014 </td><td>XBAR_NUM_PORTS </td><td>RO </td><td>See crossbar kernel driver </td></tr>
<tr>
<td>4001_1018 </td><td>LOCAL_ADDR </td><td>RW </td><td>See crossbar kernel driver </td></tr>
<tr>
<td>4001_1020 </td><td>remote_offset </td><td>WO </td><td>XBAR settings reg </td></tr>
<tr>
<td>4001_1420 </td><td>local_offset </td><td>WO </td><td>XBAR settings reg </td></tr>
<tr>
<td rowspan="7">n3xx_mgt_io_core (NPIO0) </td><td>4001_0200 </td><td>PORT_INFO </td><td>RO </td><td></td></tr>
<tr>
<td>4001_0204 </td><td>MAC_CTRL_STATUS </td><td>RW </td><td></td></tr>
<tr>
<td>4001_0208 </td><td>PHY_CTRL_STATUS </td><td>RW </td><td></td></tr>
<tr>
<td>4001_0220 </td><td>AURORA_OVERUNS </td><td>RO </td><td></td></tr>
<tr>
<td>4001_0224 </td><td>AURORA_CHECKSUM_ERRORS</td><td>RO </td><td></td></tr>
<tr>
<td>4001_0228 </td><td>AURORA_BIST_CHECKER_SAMPS</td><td>RO </td><td></td></tr>
<tr>
<td>4001_022c </td><td>AURORA_BIST_CHECKER_ERRORS</td><td>RO</td><td></td></tr>
<tr>
<td rowspan="7">n3xx_mgt_io_core (NPIO1) </td><td>4001_0240 </td><td>PORT_INFO </td><td>RO </td><td></td></tr>
<tr>
<td>4001_0244 </td><td>MAC_CTRL_STATUS </td><td>RW </td><td></td></tr>
<tr>
<td>4001_0248 </td><td>PHY_CTRL_STATUS </td><td>RW </td><td></td></tr>
<tr>
<td>4001_0260 </td><td>AURORA_OVERUNS </td><td>RO </td><td></td></tr>
<tr>
<td>4001_0264 </td><td>AURORA_CHECKSUM_ERRORS</td><td>RO</td><td></td></tr>
<tr>
<td>4001_0268 </td><td>AURORA_BIST_CHECKER_SAMPS</td><td>RO</td><td></td></tr>
<tr>
<td>4001_026c </td><td>AURORA_BIST_CHECKER_ERRORS</td><td>RO</td><td></td></tr>
<tr>
<td rowspan="7">n3xx_mgt_io_core (QSFP0) </td><td>4001_0280 </td><td>PORT_INFO</td><td>RO</td><td></td></tr>
<tr>
<td>4001_0284 </td><td>MAC_CTRL_STATUS</td><td>RW</td><td></td></tr>
<tr>
<td>4001_0288 </td><td>PHY_CTRL_STATUS</td><td>RW</td><td></td></tr>
<tr>
<td>4001_02a0 </td><td>AURORA_OVERUNS</td><td>RO</td><td></td></tr>
<tr>
<td>4001_02a4 </td><td>AURORA_CHECKSUM_ERRORS</td><td>RO</td><td></td></tr>
<tr>
<td>4001_02a8 </td><td>AURORA_BIST_CHECKER_SAMPS</td><td>RO</td><td></td></tr>
<tr>
<td>4001_02ac </td><td>AURORA_BIST_CHECKER_ERRORS</td><td>RO</td><td></td></tr>
<tr>
<td rowspan="7">n3xx_mgt_io_core (QSFP1) </td><td>4001_02c0 </td><td>PORT_INFO</td><td>RO</td><td></td></tr>
<tr>
<td>4001_02c4 </td><td>MAC_CTRL_STATUS</td><td>RW</td><td></td></tr>
<tr>
<td>4001_02c8 </td><td>PHY_CTRL_STATUS</td><td>RW</td><td></td></tr>
<tr>
<td>4001_02e0 </td><td>AURORA_OVERUNS</td><td>RO</td><td></td></tr>
<tr>
<td>4001_02e4 </td><td>AURORA_CHECKSUM_ERRORS</td><td>RO</td><td></td></tr>
<tr>
<td>4001_02e8 </td><td>AURORA_BIST_CHECKER_SAMPS</td><td>RO</td><td></td></tr>
<tr>
<td>4001_02ec </td><td>AURORA_BIST_CHECKER_ERRORS</td><td>RO</td><td></td></tr>
<tr>
<td rowspan="7">n3xx_mgt_io_core (QSFP2) </td><td>4001_0300 </td><td>PORT_INFO</td><td>RO</td><td></td></tr>
<tr>
<td>4001_0304 </td><td>MAC_CTRL_STATUS</td><td>RW</td><td></td></tr>
<tr>
<td>4001_0308 </td><td>PHY_CTRL_STATUS</td><td>RW</td><td></td></tr>
<tr>
<td>4001_0320 </td><td>AURORA_OVERUNS</td><td>RO</td><td></td></tr>
<tr>
<td>4001_0324 </td><td>AURORA_CHECKSUM_ERRORS</td><td>RO</td><td></td></tr>
<tr>
<td>4001_0328 </td><td>AURORA_BIST_CHECKER_SAMPS</td><td>RO</td><td></td></tr>
<tr>
<td>4001_032c </td><td>AURORA_BIST_CHECKER_ERRORS</td><td>RO</td><td></td></tr>
<tr>
<td rowspan="7">n3xx_mgt_io_core (QSFP3) </td><td>4001_0340 </td><td>PORT_INFO</td><td>RO</td><td></td></tr>
<tr>
<td>4001_0344 </td><td>MAC_CTRL_STATUS</td><td>RW</td><td></td></tr>
<tr>
<td>4001_0348 </td><td>PHY_CTRL_STATUS</td><td>RW</td><td></td></tr>
<tr>
<td>4001_0360 </td><td>AURORA_OVERUNS</td><td>RO</td><td></td></tr>
<tr>
<td>4001_0364 </td><td>AURORA_CHECKSUM_ERRORS</td><td>RO</td><td></td></tr>
<tr>
<td>4001_0368 </td><td>AURORA_BIST_CHECKER_SAMPS</td><td>RO</td><td></td></tr>
<tr>
<td>4001_036C </td><td>AURORA_BIST_CHECKER_ERRORS</td><td>RO</td><td><p class="starttd"></p>
<p class="endtd"></p>
</td></tr>
<tr>
<td rowspan="6">Slave 5 </td><td>4001_4000</td><td>4001_41FF</td><td>Clocking</td><td>see Clocking regmap</td><td></td></tr>
<tr>
<td>4001_4200</td><td>4001_43FF</td><td>Sync</td><td>see Sync regmap</td><td></td></tr>
<tr>
<td>4001_4400</td><td>4001_45FF</td><td>open</td><td>open</td><td>open</td><td></td></tr>
<tr>
<td>4001_4600</td><td>4001_47FF</td><td>Daughterboard </td><td>see Daughterboard regmap (EISCAT)</td><td></td></tr>
<tr>
<td>4001_6000</td><td>4001_6FFF</td><td>JESD Core 0</td><td>see JESD regmap (EISCAT)</td><td></td></tr>
<tr>
<td>4001_7000</td><td>4001_7FFF</td><td>JESD Core 1</td><td>see JESD regmap (EISCAT)</td><td></td></tr>
<tr>
<td rowspan="1">Slave 6 </td><td>4001_8000 - 4001_bfff </td><td>see above </td><td>-</td><td>same as Slave 5</td><td></td></tr>
</table>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
